#! /usr/bin/python
# -*- coding: utf-8 -*-

# import modules used here -- sys is a very standard one
import sys, os, os.path
import re, getopt
from xml.etree import ElementTree as ET
#from xml.etree.ElementTree import Element, SubElement, Comment, tostring
from xml.dom import minidom
from operator import itemgetter, attrgetter
import pickle
#import sqlite3 as sqlite
#import subprocess, time
#import signal, datetime
#import logging
import datetime

# curl -O -sv -d @body https://www.silicondust.com/hdhomerun/lineupui?Cmd=IdentifyPrograms2

time_now = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')

def scan_channel( ch_entry ):
	chan = {}
	chan['1'] = ch_entry.pop(0)			# scanning
	chan['2'] = ch_entry.pop(0)			# lock
	chan['prog'] = []

	if chan['2'].startswith('LOCK: none') == False and len(ch_entry):
		chan['3'] = ch_entry.pop(0)		# tsid

		for line in ch_entry:
			if line.endswith('(encrypted)\n') == False:
				chan['prog'].append( line )

		if len(chan['prog']) == 0:
			return {}
	else:
		return {}

	entry = {}

#	print chan['1']
	m = re.match(r"\w+: (\d+) .+ (\S+):(\d+)",chan['1'])
#	print m.groups()
	entry['freq'] = m.group(1)
	entry['src'] = m.group(2)
	entry['chan'] = m.group(3)

#	print chan['2']
	m = re.match(r"\w+: (\w+\d+) ", chan['2'])
#	print m.groups()
	entry['lock'] = m.group(1)

#	print chan['3']
	m = re.match(r"TSID: (0x\S+)", chan['3'])
#	print m.groups()
	entry['tsid'] = m.group(1)

	entry['prog'] = {}
#	print chan['prog']
	for ch_prog in chan['prog']:
		m = re.match(r"PROGRAM (\d+): (.+)", ch_prog)
#		print m.groups()
		entry['prog'][m.group(1)] = {}
		if m.group(2) == "0":
			vname = ['{0}.{1}'.format(entry['chan'],m.group(1)[-3:]),'' ]
		else:
			vname = m.group(2).split(' ',1)

		entry['prog'][ m.group(1) ]['vname'] = vname
#		entry['prog'][ m.group(1) ]['gname'] = ['','']

#	print ">", entry

	return entry

def scan_file(f,x):
	chan = []
	e = {}
	ch_list = {}

	for line in f:
		if line.startswith('SCANNING:') == False:
			chan.append( line )
		else:
			if len(chan):
				e = scan_channel( chan )

				if len(e):
					ch_list[int(e['tsid'],0)] = e
					del e['tsid']
#					ch_list.append( e )
#					print ".", e

			chan = [ line ];

	if len(chan):
		e = scan_channel( chan )
		if len(e):
			ch_list[e['tsid']] = e
			del e['tsid']
#			ch_list.append( e )
#			print ".", e

	if len(ch_list):
	
		root = ET.Element('LineupUIRequest')
		child = ET.SubElement(root, 'Vendor')
		child.text = 'SiliconDust USA'
		child = ET.SubElement(root, 'Application')
		child.text = 'hrtool'
		child = ET.SubElement(root, 'Command')
		child.text = 'IdentifyPrograms2'
		child = ET.SubElement(root, 'UserID')
		child.text = 'hrtool-123'
		child.tail = '['
		child = ET.SubElement(root, 'DeviceID')
		child.text = '10342652'
		child.tail = ']'
		child = ET.SubElement(root, 'Location')
		child.text = 'US:94061'

#		print ch_list
		for ch in ch_list:
#			print ch, ch_list[ch]
			for pr in ch_list[ch]['prog']:
#				print '\t', pr
				program = ET.SubElement(root, 'Program')
				child = ET.SubElement(program, 'Modulation')
				child.text = ch_list[ch]['lock']
				child = ET.SubElement(program, 'Frequency')
				child.text = ch_list[ch]['freq']
				child = ET.SubElement(program, 'TransportStreamID')
				child.text = "%d" % ch
				child = ET.SubElement(program, 'ProgramNumber')
				child.text = pr 
				child = ET.SubElement(program, 'SeenTimestamp')
				child.text = time_now

		tree = ET.ElementTree(root)
		xml_string = ET.tostring(root,encoding="UTF-8")	# missing standalone="yes"
#		print xml_string

		xml = minidom.parseString(xml_string)
		print xml.toprettyxml()

		pickle.dump(ch_list, open('hrtool.dat','wb'))

	return

def chan_map(f):
	ch_list = pickle.load(open('hrtool.dat','rb'))
	prg_list = {}

#	for ch in ch_list: print ch

	try:
		tree = ElementTree.parse(f)
	except Exception, inst:
		print "error; %s: %s" % (f, inst)

	print "TUNE,VNUM,VNAME,GNUM,GNAME"

	for p in list(tree.iterfind('Program')):
		mod = p.find('Modulation')
		frq = p.find('Frequency')
		sid = p.find('TransportStreamID')
		pn  = p.find('ProgramNumber')
		gnum = p.find('GuideNumber')
		gnam = p.find('GuideName')

		if gnum is not None:
#			print "{0}-{1} = ({2}:{3})".format( sid.text, pn.text, gnum.text, gnam.text)
#			ch_list[int(sid.text)]['prog'][pn.text]['gname'] = "{0} {1}".format( gnum.text, gnam.text )
			ch_list[int(sid.text)]['prog'][pn.text]['gname'] = [gnum.text, gnam.text]
		else:
			ch_list[int(sid.text)]['prog'][pn.text]['gname'] = ['','']

#	for ch in ch_list: print ch, ch_list[ch]

	for k,v in sorted(ch_list.items(), key=lambda v: int(v[1]['chan'])):
#		print k,"=",v['prog'] 
		for p in v['prog']:
#			if v['prog'][p]['vname'] == "0":
#				v['prog'][p]['vname'] = "0 ";

			line = [ "{0}-{1}".format( v['chan'],p) ]
			line.extend( v['prog'][p]['vname'] )
			line.extend( v['prog'][p]['gname'] )

			line = ','.join(map(str,line))

			print line

#			print '"ch{0}-{1}","{2}","{3}"'.format(
#					v['chan'],p, vn[0], vn[1] )

	return

def usage():
	print 'Usage: -f <file> -x'
	return

# Gather our code in a main() function
def main():
	try:
		opts, args = getopt.getopt(sys.argv[1:], "hf:xc", "help")
	except getopt.GetoptError, err:
		print str(err)
		usage()
		sys.exit(2)

	o_mode = 1
	o_file = None
	o_xml = False

	for o, a in opts:
		if o in ("-h", "--help"):
			usage()
			sys.exit()
		elif o == "-f":
			o_file = a
		elif o == "-x":
			o_xml = True
		elif o == '-c':
			o_mode = 2



	if o_file == "-":
		o_file = sys.stdin
	else:
		o_file = open(o_file, 'r')

	if o_mode == 1:
		scan_file( o_file, o_xml )
	else:
		chan_map( o_file )

# Standard boilerplate to call the main() function to begin
# the program.
if __name__ == '__main__':
	main()

